---
description: Instructions for reading/writing Memory Bank via Notion MCP. Load with memory-bank-paths when using Notion backend.
globs: notion-memory-bank-ops.mdc
alwaysApply: false
---

# NOTION MEMORY BANK - READ/WRITE OPERATIONS

Use identifiers from `.cursor/notion-memory-bank.json`. **PROJECT-** prefix → Projects database; **TASK-** prefix → Tasks database.

**Config updates (MANDATORY):** Before writing `.cursor/notion-memory-bank.json`:
1. **Read** the current file.
2. For each field you intend to update, compare new value with current value.
3. **If all values are unchanged** → do NOT write the file (skip entirely).
4. **If at least one value differs** → write only the changed fields, merge with existing content.
Never write the file when no field value actually changes.

**Format:** Write `.cursor/notion-memory-bank.json` as formatted JSON (2-space indentation, one key per line). **Always** parse existing content, merge changes, then serialize with `JSON.stringify(obj, null, 2)` – never write minified single-line JSON.

**Language:** All content written to Notion (page body, properties) MUST be in **English**.

**Page links:** To reference an existing page (e.g. References, progress): use `<mention-page url="[URL]">[Title]</mention-page>`. Use `<page url="...">` only when preserving child pages during replace_content_range (keeps structure). Do NOT use `<page>` for cross-references – that can move pages. **Reflection/Archive subpages under Task:** Use ONLY `<page url="...">` – do NOT add `<mention-page>` (creates redundant "Title: [link]" display).

## Resolve Identifier to Page

1. **PROJECT-X**: `notion-search` with `data_source_url` = `projectsDataSourceUrl`, `query` = `PROJECT-X` or `X`. Use page URL from first result.
2. **TASK-Y**: `notion-search` with `data_source_url` = `tasksDataSourceUrl`, `query` = `TASK-Y` or `Y`. Use page URL from first result.
3. Then `notion-fetch` with the resolved page URL/ID.

## Read Tasks (plan, checklist)

- Resolve `taskId` (e.g. TASK-588) → `notion-fetch` the Task page – content lives in page body

## Read ProjectBrief / ActiveContext / Progress / ProductContext / SystemPatterns / TechContext / StyleGuide

- projectBrief: Resolve `projectId` → `notion-fetch` (page body)
- activeContext: If `activeContextPageId` set → `notion-fetch`. If null → **create first** (notion-verification), then fetch.
- progress: If `progressPageId` set → `notion-fetch`. If null → **create first** (notion-verification), then fetch.
- productContext, systemPatterns, techContext, styleGuide: If respective page ID set → `notion-fetch`. If null → notion-verification creates them; then fetch.

## Create Missing Subpages (MANDATORY when config IDs are null)

**Note:** For Project subpages (activeContext, progress, productContext, systemPatterns, techContext, styleGuide), use **notion-verification.mdc** which implements search-before-create to avoid duplicates. The steps below are for activeContext and progress only; notion-verification handles all six when running VAN or other commands that load it.

**Project subpages** (activeContext, progress): Resolve `projectId` → get Project page ID. For each null ID:
1. `notion-search` with `query: "Active Context <projectId>"` or `"Progress <projectId>"` (e.g. "Active Context PROJECT-37"), `page_url: projectPageUrl` to find existing subpage. If found, use its ID. **Otherwise** `notion-create-pages` with `parent: { page_id: projectPageId }`, `pages: [{ properties: { title: "Active Context <projectId>" } }]` or `pages: [{ properties: { title: "Progress <projectId>" } }]` respectively.
2. Extract created page ID from tool response (or use resolved ID from search)
3. **Update** `.cursor/notion-memory-bank.json` with the new `activeContextPageId` or `progressPageId` (skip if value unchanged)

**Task subpages** (creative, reflection, archive): For each ID (creativePageId, reflectionPageId, archivePageId):
1. If ID is set: `notion-fetch` to verify page exists and is not deleted. **Stale check**: If page parent ≠ resolved Task page ID → treat as stale, clear ID in config, then treat as null.
2. If ID is null or page is deleted/stale: `notion-create-pages` with `parent: { page_id: taskPageId }`, `pages: [{ properties: { title: "Creative TASK-Y" } }]` or `pages: [{ properties: { title: "Reflection TASK-Y" } }]` or `pages: [{ properties: { title: "Archive TASK-Y" } }]` (use `taskId` from config, e.g. TASK-1391). Extract new ID, update config only if the new value differs from current.

## Write Tasks / ActiveContext / Progress / ProductContext / SystemPatterns / TechContext / StyleGuide

- `notion-update-page` with `command: "replace_content"` and `new_str` = full Markdown content
- Use the resolved page ID from the identifier

## Task Subpages (Creative, Reflection, Archive)

- Use `creativePageId`, `reflectionPageId`, `archivePageId` if set
- If null: Follow **Create Missing Subpages** above (Task subpages). Config update is REQUIRED.

## Update Task Status

- `notion-update-page` with `command: "update_properties"` on the Task page (e.g. Status = "Done")
- When archiving (task complete): Update Dates property – if current Dates has start, keep it as start and set end = today; if empty, set start = today, end = today. Use `date:Dates:start`, `date:Dates:end`, `date:Dates:is_datetime` (0). **Get today**: run `date +%Y-%m-%d`.
